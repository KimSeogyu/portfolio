// Code generated by MockGen. DO NOT EDIT.
// Source: internal/dlock/dlock.go
//
// Generated by this command:
//
//	mockgen -source=internal/dlock/dlock.go -destination=internal/dlock/mocks/dlock.go
//

// Package mock_dlock is a generated GoMock package.
package mock_dlock

import (
	context "context"
	reflect "reflect"

	redsync "github.com/go-redsync/redsync/v4"
	dlock "github.com/kimseogyu/portfolio/backend/internal/dlock"
	gomock "go.uber.org/mock/gomock"
)

// MockDLockerFactory is a mock of DLockerFactory interface.
type MockDLockerFactory struct {
	ctrl     *gomock.Controller
	recorder *MockDLockerFactoryMockRecorder
	isgomock struct{}
}

// MockDLockerFactoryMockRecorder is the mock recorder for MockDLockerFactory.
type MockDLockerFactoryMockRecorder struct {
	mock *MockDLockerFactory
}

// NewMockDLockerFactory creates a new mock instance.
func NewMockDLockerFactory(ctrl *gomock.Controller) *MockDLockerFactory {
	mock := &MockDLockerFactory{ctrl: ctrl}
	mock.recorder = &MockDLockerFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDLockerFactory) EXPECT() *MockDLockerFactoryMockRecorder {
	return m.recorder
}

// NewMutex mocks base method.
func (m *MockDLockerFactory) NewMutex(key string, opts ...redsync.Option) dlock.DLocker {
	m.ctrl.T.Helper()
	varargs := []any{key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewMutex", varargs...)
	ret0, _ := ret[0].(dlock.DLocker)
	return ret0
}

// NewMutex indicates an expected call of NewMutex.
func (mr *MockDLockerFactoryMockRecorder) NewMutex(key any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewMutex", reflect.TypeOf((*MockDLockerFactory)(nil).NewMutex), varargs...)
}

// MockDLocker is a mock of DLocker interface.
type MockDLocker struct {
	ctrl     *gomock.Controller
	recorder *MockDLockerMockRecorder
	isgomock struct{}
}

// MockDLockerMockRecorder is the mock recorder for MockDLocker.
type MockDLockerMockRecorder struct {
	mock *MockDLocker
}

// NewMockDLocker creates a new mock instance.
func NewMockDLocker(ctrl *gomock.Controller) *MockDLocker {
	mock := &MockDLocker{ctrl: ctrl}
	mock.recorder = &MockDLockerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDLocker) EXPECT() *MockDLockerMockRecorder {
	return m.recorder
}

// LockContext mocks base method.
func (m *MockDLocker) LockContext(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LockContext", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// LockContext indicates an expected call of LockContext.
func (mr *MockDLockerMockRecorder) LockContext(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LockContext", reflect.TypeOf((*MockDLocker)(nil).LockContext), ctx)
}

// UnlockContext mocks base method.
func (m *MockDLocker) UnlockContext(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnlockContext", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnlockContext indicates an expected call of UnlockContext.
func (mr *MockDLockerMockRecorder) UnlockContext(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnlockContext", reflect.TypeOf((*MockDLocker)(nil).UnlockContext), ctx)
}
